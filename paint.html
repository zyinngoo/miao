<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>画图</title>
  <style>
    canvas {
      border: 2px solid #f0f;
      display: block;
      margin: auto;
    }


  </style>
</head>
<body>
  <canvas width="500" height="400"></canvas>
</body>
<script>
  var canvas = document.querySelector('canvas')
  canvas.style.imageRendering = 'pixelated' //放大时的插帧方式：不插帧，直接放大像素
  var ctx = canvas.getContext('2d')

  function dot(x, y, color = 'black') {
    x = Math.round(x)
    y = Math.round(y)
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
  /**
   * YOUR TASK
      * 在 坐标 (42, 42) 画出一个点
      * 画一条实线
      * 画一条一个实点一个空点的虚线
      * 画一条两个实点两个空点的虚线
      * 画一条三个实点两个空点的虚线
      * 画一条45度的斜线
      * 画一条30度的斜线（与x轴或y轴的夹角呈30度）
      * 画一条跨越画布左上角和右下角的对角线
      * 画一个空心矩形
      * 画一个实心矩形
      * 画两个个空心的圆，居中：
        * 一个半径为50像素
        * 一个半径为200像素
      * 画一个实心的圆，半径至少为100像素
      * 画一个【大小合适】的sin(x)的图像

      * 画出rgb色彩空间的某一面（尺寸要大于100x100）
         'rgb(255,255,0)'
         '#ff00ff'
        如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变幻后的色彩空间某一面
        可以考虑如下几种矩阵：
           2 0
           0 2
           ------
           1  0.27
           0  1
           ------
           0.5    0.87
           -0.87  0.5

   */
</script>
<script>
  // 不可更改上面的代码
  // 你的代码写在这里
  // YOUR CODE GOES BELOW

  // 在 坐标 (42, 42) 画出一个点

  dot ( 42 , 42 , "black")

  // 画一条实线

  for ( var x = 0 ; x < 600 ; x++) {
    dot ( x , 50 , "black" )
  }
  // 画一条一个实点一个空点的虚线

  for ( var x = 0 ; x < 600 ; x += 2) {
    dot ( x , 55 , "black" )
  }

  // 画一条两个实点两个空点的虚线

  var x = -3 ;
  for ( var i = 0 ; i < 600 ; i++) {
    dot ( x = x + 3 , 60 , "black" )
    dot ( x = x + 1 , 60 , "black" )
  }

  // 画一条三个实点两个空点的虚线

  for (var x = 0 ; x < 600 ; x++) {
    if (x % 5 < 3 ) {
      dot (x , 65 , "black")
    }
  }

  // 画一条45度的斜线

  var x = 70 ;
  var y = 70 ;
  for ( var i = 0 ; i < 50 ; i++) {
    dot ( x++ , y++ , "black" )
  }
  // 画一条30度的斜线（与x轴或y轴的夹角呈30度）


  for ( var y = 0 ; y < 50 ; y++) {
    var x = Math.sqrt(3) * y / 3 - 15
    dot ( x + 50 , y + 70 , "pink" )
  }

  // 画一条跨越画布左上角和右下角的对角线

  for ( var x = 0 ; x < 500 ; x++) {
    y = 0.8 * x
    dot ( x , y , "gold" )
  }

  // 画一个空心矩形

  var x = 1 ;
  var y = 200 ;
  for ( var i = 0 ; i < 300 ; i++) {

    if (i < 100) {
      dot ( x++ , y , "black" )
    } else if (i < 150) {
      dot ( x , y++ , "black" )
    } else if ( i < 250) {
      dot ( x-- , y , "black" )
    } else if ( i < 300 ) {
      dot ( x , y-- , "black" )
    }
  }

  // 画一个实心矩形

  var x = 5 ;
  var y = 205 ;
  for ( var i = 0 ; i < 1250 ; i++) {

    if (i % 50 == 0){
      y = y + 1
      x = 5
    }
    dot ( x++ , y , "pink" )

  }

  // 画两个个空心的圆，居中：
  // * 一个半径为50像素

  var r = 50

  for (var x = - r ; x <=  r ;  x++ ) {
    var y = Math.sqrt(r * r - x * x)
    dot ( x + 250, y + 200, 'black')
    dot ( x + 250 , -y + 200, 'black')
  }
  for (var y = -r ; y <= r ;  y++ ) {
    var x = Math.sqrt(r * r - y * y)
    dot ( x + 250, y + 200, 'black')
    dot ( -x + 250 , y + 200, 'black')
  }

  // * 一个半径为200像素

  var r = 70
  var x = 0
  var y = r

  while (x <= y) {
    dot ( x + 250, y + 200, 'black')
    dot ( x + 250, -y + 200, 'black')
    dot ( -x + 250, y + 200, 'black')
    dot ( -x + 250, -y + 200, 'black')
    dot ( y + 250, x + 200, 'black')
    dot ( y + 250, -x + 200, 'black')
    dot ( -y + 250, x + 200, 'black')
    dot ( -y + 250, -x + 200, 'black')

    x++

    var d1 = x * x + y * y
    var d2 = x * x + (y - 1) * (y - 1)

    if (Math.abs(d1 - r * r) >  Math.abs( d2 - r * r)) {
    y--
    }
  }

  // 画一个实心的圆，半径至少为100像素


  for (var r = 1 ; r <= 100 ; r++ ) { // 半径
    var x = 0
    var y = r

    while (x <= y) {
      dot ( x + 400, y + 300, 'black')
      dot ( x + 400, -y + 300, 'black')
      dot ( -x + 400, y + 300, 'black')
      dot ( -x + 400, -y + 300, 'black')
      dot ( y + 400, x + 300, 'black')
      dot ( y + 400, -x + 300, 'black')
      dot ( -y + 400, x + 300, 'black')
      dot ( -y + 400, -x + 300, 'black')

      x++

      var d1 = x * x + y * y
      var d2 = x * x + (y - 1) * (y - 1)

      if (Math.abs(d1 - r * r) >  Math.abs( d2 - r * r)) {
      y--
       }
    }
  }



  // 画一个【大小合适】的sin(x)的图像

  var x = 200 ;
  var y = 0 ;
  for (var i = 1 ; i <= 300 ; i++ ) {
      y = 20 * Math.sin(x / 20) + 100
      var color = 'hsl(' + x + ', 60% , 80% )'
      dot(x++ , y , color)
  }

  // 画出rgb色彩空间的某一面（尺寸要大于100x100）


  for ( var y = 0 ; y < 100 ; y++ ) {
    for (var x = 0 ; x < 100 ; x++ ) {
      var color = 'rgb(255,' + x * 2.55 +  ',' + y * 2.55 + ')'
      var xx = x
      var yy = y
      dot(xx  , yy + 260 , color)
    }
  }
  //  'rgb(255,255,0)'
  //  '#ff00ff'
  // 如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变幻后的色彩空间某一面
  // 可以考虑如下几种矩阵：
  //    2 0
  //    0 2
  //    ------
  //    1  0.27
  //    0  1
  //    ------
  //    0.5    0.87
  //    -0.87  0.5
</script>
</html>
