<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>画图</title>
  <style>
    canvas {
      border: 2px solid #f0f;
      display: block;
      margin: auto;
    }


  </style>
</head>
<body>
  <canvas width="500" height="400"></canvas>
</body>
<script>
  var canvas = document.querySelector('canvas')
  canvas.style.imageRendering = 'pixelated' //放大时的插帧方式：不插帧，直接放大像素
  var ctx = canvas.getContext('2d')

  function dot(x, y, color = 'black') {
    x = Math.round(x)
    y = Math.round(y)
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
  /**
   * YOUR TASK
      * 在 坐标 (42, 42) 画出一个点
      * 画一条实线
      * 画一条一个实点一个空点的虚线
      * 画一条两个实点两个空点的虚线
      * 画一条三个实点两个空点的虚线
      * 画一条45度的斜线
      * 画一条30度的斜线（与x轴或y轴的夹角呈30度）
      * 画一条跨越画布左上角和右下角的对角线
      * 画一个空心矩形
      * 画一个实心矩形
      * 画两个个空心的圆，居中：
        * 一个半径为50像素
        * 一个半径为200像素
      * 画一个实心的圆，半径至少为100像素
      * 画一个【大小合适】的sin(x)的图像

      * 画出rgb色彩空间的某一面（尺寸要大于100x100）
         'rgb(255,255,0)'
         '#ff00ff'
        如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变幻后的色彩空间某一面
        可以考虑如下几种矩阵：
           2 0
           0 2
           ------
           1  0.27
           0  1
           ------
           0.5    0.87
           -0.87  0.5

   */
</script>
<script>
  // 不可更改上面的代码
  // 你的代码写在这里
  // YOUR CODE GOES BELOW

  // 在 坐标 (42, 42) 画出一个点

  dot ( 42 , 42 , "black")

  // 画一条实线

  var x = 0 ;
  for ( var i = 0 ; i < 600 ; i++) {
    dot ( x++ , 50 , "black" )
  }
  // 画一条一个实点一个空点的虚线

  var x = -2 ;
  for ( var i = 0 ; i < 600 ; i++) {
    dot ( x=x+2 , 55 , "black" )
  }

  // 画一条两个实点两个空点的虚线

  var x = -3 ;
  for ( var i = 0 ; i < 600 ; i++) {
    dot ( x = x + 3 , 60 , "black" )
    dot ( x = x + 1 , 60 , "black" )
  }

  // 画一条三个实点两个空点的虚线

  var x = -4 ;
  for ( var i = 0 ; i < 600 ; i++) {
    dot ( x = x + 4 , 65 , "black" )
    dot ( x = x + 1 , 65 , "black" )
    dot ( x = x + 1 , 65 , "black" )
  }

  // 画一条45度的斜线

  var x = 70 ;
  var y = 70 ;
  for ( var i = 0 ; i < 50 ; i++) {
    dot ( x++ , y++ , "black" )
  }
  // 画一条30度的斜线（与x轴或y轴的夹角呈30度）

  var x = 50 ;
  var y = 50 ;
  for ( var i = 0 ; i < 50 ; i++) {
    y = Math.sqrt(3) * x - 15
    dot ( x++ , y , "pink" )
  }

  // 画一条跨越画布左上角和右下角的对角线

  var x = 0 ;
  for ( var i = 0 ; i < 500 ; i++) {
    y = 0.8 * x
    dot ( x++ , y , "gold" )
  }

  // 画一个空心矩形

  var x = 1 ;
  var y = 200 ;
  for ( var i = 0 ; i < 300 ; i++) {

    if (i < 100) {
      dot ( x++ , y , "black" )
    } else if (i < 150) {
      dot ( x , y++ , "black" )
    } else if ( i < 250) {
      dot ( x-- , y , "black" )
    } else if ( i < 300 ) {
      dot ( x , y-- , "black" )
    }
  }

  // 画一个实心矩形

  var x = 5 ;
  var y = 205 ;
  for ( var i = 0 ; i < 1250 ; i++) {

    if (i % 50 == 0){
      y = y + 1
      x = 5
    }
    dot ( x++ , y , "pink" )

  }

  // 画两个个空心的圆，居中：
  // * 一个半径为50像素

  var x = 250 ;
  var y = 200 ;
  dot ( x , y , "black" )
  for ( var i = 0 ; i < 200 ; i++) {
    y = Math.sqrt (50 * 50 - ( x - 250 ) ** 2)
    if ( i < 50 || i > 150 ) {
      y = -y + 200
      dot ( x++ , y , "pink" )
    } else {
      y = y + 200
      dot ( x-- , y , "pink" )
    }
  }

  // * 一个半径为200像素

  var x = 250 ;
  var y = 200 ;
  for ( var i = 0 ; i < 360 ; i++) {
  dot ( x + Math.sin(i * Math.PI/180) * 200 , y + Math.cos(i * Math.PI/180) * 200 , "black")
  }

  // 画一个实心的圆，半径至少为100像素

  var x = 400 ;
  var y = 300 ;
  dot ( x , y , "black" )
  for ( var i = 0 ; i < 400 ; i++) {
    y = Math.sqrt (10000 - ( x - 400 ) ** 2)
    if ( i < 100 || i > 300 ) {
      y = -y + 300
      dot ( x++ , y  , "pink" )
    } else {
      y = y +300
      dot ( x-- , y  , "pink" )
    }
  }
  // 画一个【大小合适】的sin(x)的图像

  // 画出rgb色彩空间的某一面（尺寸要大于100x100）
  //  'rgb(255,255,0)'
  //  '#ff00ff'
  // 如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变幻后的色彩空间某一面
  // 可以考虑如下几种矩阵：
  //    2 0
  //    0 2
  //    ------
  //    1  0.27
  //    0  1
  //    ------
  //    0.5    0.87
  //    -0.87  0.5
</script>
</html>
